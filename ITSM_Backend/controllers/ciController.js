const config = require("../db/config.json");
const pool = require("../db/db");
const XLSX = require("xlsx");

const addCi = async (req, res) => {
  const {
    ci_name,
    ci_description,
    user_id, // This now refers to ci_owner_id
    ci_service_id,
    ci_classification_id,
    ci_category_id,
  } = req.body;

  const client = await pool.connect(); // Use a client to manage transactions
  try {
    await client.query("BEGIN"); // Start transaction

    // Step 1: Insert into `ci` table (created_at will be auto-generated by the DB)
    const insertCiQuery = `
      INSERT INTO ci (ci_name, description)
      VALUES ($1, $2)
      RETURNING ci_id;
    `;
    const ciValues = [ci_name, ci_description];
    const ciResult = await client.query(insertCiQuery, ciValues);
    const ci_id = ciResult.rows[0].ci_id; // Get the newly inserted ci_id

    // Step 2: Insert into `user_ci_relation` table using the new `ci_id`
    const insertRelationQuery = `
      INSERT INTO user_ci_relation (user_id, ci_service_id, ci_classification_id, ci_category_id, ci_id)
      VALUES ($1, $2, $3, $4, $5);
    `;
    const relationValues = [
      user_id,
      ci_service_id,
      ci_classification_id,
      ci_category_id,
      ci_id,
    ];
    await client.query(insertRelationQuery, relationValues);

    // Step 3: Insert into `ci_assigned_to` table
    const insertAssignedQuery = `
      INSERT INTO ci_assigned_to (ci_id, user_id)
      VALUES ($1, $2);
    `;
    const assignedValues = [ci_id, user_id];
    await client.query(insertAssignedQuery, assignedValues);

    await client.query("COMMIT"); // Commit transaction

    // Return the newly inserted CI
    res.status(201).json(ciResult.rows[0]);
  } catch (err) {
    await client.query("ROLLBACK"); // Rollback transaction in case of error
    console.error(err.message);
    res.status(500).json({ error: "Server error" });
  } finally {
    client.release(); // Release the client back to the pool
  }
};

const ciBulkUpload = async (req, res) => {
  const client = await pool.connect(); // Get a client from the pool

  try {
    const file = req.file;
    console.log("Uploaded file:", file);

    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];

    // Convert the sheet data to JSON format
    const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
    console.log("Parsed data:", data);

    if (data.length < 3) {
      throw new Error("The uploaded file doesn't contain enough rows.");
    }

    // First row: header
    const header = data[0];
    console.log("Header:", header);

    // Second row: body headings (assumed to be consistent with DB columns)
    const bodyHeading = data[1];
    console.log("Body Heading:", bodyHeading);

    // Remaining rows: CI data
    const ciRows = data.slice(2);
    console.log("CI Data Rows:", ciRows);

    // Begin transaction
    await client.query("BEGIN");

    for (const row of ciRows) {
      const [
        ci_name,
        ci_description,
        user_name, // Assuming user_name is a single column (e.g., "John Doe")
        ci_service_name,
        ci_classification_name,
        ci_category_name,
      ] = row;

      // Split the user_name into first and last name
      const [first_name, last_name] = user_name.split(" ");

      // Fetch user_id
      const userQuery = `
        SELECT user_id 
        FROM user_details 
        WHERE CONCAT(first_name, ' ', last_name) = $1
      `;
      const userResult = await client.query(userQuery, [user_name]);
      const user_id = userResult.rows.length
        ? userResult.rows[0].user_id
        : null;
      if (!user_id) throw new Error(`User ${user_name} not found`);

      // Fetch ci_service_id
      const serviceQuery = `SELECT service_id FROM service WHERE service_name = $1`;
      const serviceResult = await client.query(serviceQuery, [ci_service_name]);
      const ci_service_id = serviceResult.rows.length
        ? serviceResult.rows[0].service_id
        : null;
      if (!ci_service_id)
        throw new Error(`Service ${ci_service_name} not found`);

      // Fetch ci_classification_id
      const classificationQuery = `
        SELECT ci_classification_id FROM ci_classification WHERE ci_classification_name = $1
      `;
      const classificationResult = await client.query(classificationQuery, [
        ci_classification_name,
      ]);
      const ci_classification_id = classificationResult.rows.length
        ? classificationResult.rows[0].ci_classification_id
        : null;
      if (!ci_classification_id)
        throw new Error(
          `CI Classification ${ci_classification_name} not found`
        );

      // Fetch ci_category_id
      const categoryQuery = `
        SELECT ci_category_id FROM ci_category WHERE ci_category_name = $1
      `;
      const categoryResult = await client.query(categoryQuery, [
        ci_category_name,
      ]);
      const ci_category_id = categoryResult.rows.length
        ? categoryResult.rows[0].ci_category_id
        : null;
      if (!ci_category_id)
        throw new Error(`CI Category ${ci_category_name} not found`);

      // Insert CI details
      const ciQuery = `
        INSERT INTO public.ci (ci_name, description) VALUES ($1, $2)
        RETURNING ci_id
      `;
      const ciValues = [ci_name, ci_description];
      const ciResult = await client.query(ciQuery, ciValues);
      const ci_id = ciResult.rows[0].ci_id;

      // Insert into user_ci_relation
      const relationQuery = `
        INSERT INTO user_ci_relation (
          user_id,
          ci_service_id,
          ci_classification_id,
          ci_category_id,
          ci_id
        ) VALUES ($1, $2, $3, $4, $5)
      `;
      const relationValues = [
        user_id,
        ci_service_id,
        ci_classification_id,
        ci_category_id,
        ci_id,
      ];
      await client.query(relationQuery, relationValues);

      // Insert into ci_assigned_to
      const assignedToQuery = `
        INSERT INTO public.ci_assigned_to (ci_id, user_id) VALUES ($1, $2)
      `;
      const assignedToValues = [ci_id, user_id];
      await client.query(assignedToQuery, assignedToValues);
    }

    // Commit transaction
    await client.query("COMMIT");

    res.status(201).json({
      message: "CIs uploaded successfully.",
      uploadedCIs: ciRows.length,
    });
  } catch (err) {
    await client.query("ROLLBACK");
    console.error("Error uploading CIs:", err.message);
    res.status(500).json({ error: err.message });
  } finally {
    client.release(); // Release the client back to the pool
  }
};

const getCiData = async (req, res) => {
  try {
    const query = `
      SELECT
        user_details.user_id, 
        concat(user_details.first_name, ' ', user_details.last_name) AS ci_owner_name,
        ci.ci_id,
        ci.ci_name,
        ci.description AS ci_description,
        service.service_name AS ci_service_name,
        ci_classification.ci_classification_name,
        ci_category.ci_category_name
      FROM
        ci
      LEFT JOIN
        user_ci_relation ON ci.ci_id = user_ci_relation.ci_id
      LEFT JOIN
        user_details ON user_ci_relation.user_id = user_details.user_id
      LEFT JOIN
        service ON user_ci_relation.ci_service_id = service.service_id
      LEFT JOIN
        ci_classification ON user_ci_relation.ci_classification_id = ci_classification.ci_classification_id
      LEFT JOIN
        ci_category ON user_ci_relation.ci_category_id = ci_category.ci_category_id;
    `;

    const result = await pool.query(query);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "No CI data found" });
    }

    // Respond with CI data in the desired format
    res.status(200).json(result.rows);
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ error: "Server error" });
  }
};

const getCiDataById = async (req, res) => {
  const { id } = req.params;
  try {
    const query = `
      SELECT
        ci.ci_id,
        user_details.user_id,
        ci.ci_name,
        ci.description,
        service.service_id,
        ci_classification.ci_classification_id,
        ci_category.ci_category_id
      FROM
        ci
      JOIN
        user_ci_relation ON ci.ci_id = user_ci_relation.ci_id
      JOIN
        user_details ON user_ci_relation.user_id = user_details.user_id
      JOIN
        service ON user_ci_relation.ci_service_id = service.service_id
      JOIN
        ci_classification ON user_ci_relation.ci_classification_id = ci_classification.ci_classification_id
      JOIN
        ci_category ON user_ci_relation.ci_category_id = ci_category.ci_category_id
      WHERE
        ci.ci_id = $1;
    `;
    const result = await pool.query(query, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "CI not found" });
    }

    res.status(200).json(result.rows[0]);
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ error: "Server error" });
  }
};

const updateCi = async (req, res) => {
  const { ci_id } = req.params;
  const user = req.user.userId;

  console.log(req.body);
  console.log(req.params);

  const {
    ci_name,
    ci_description,
    user_id, // This now refers to ci_owner_id
    ci_service_id,
    ci_classification_id,
    ci_category_id,
  } = req.body;

  if (!ci_id) {
    return res.status(400).json({ error: "CI ID is required" });
  }

  const client = await pool.connect(); // Use a client to manage transactions

  try {
    await client.query("BEGIN"); // Start transaction

    // Step 1: Fetch current values for fields being updated
    const oldCiValues = {};
    const oldUserCiValues = {};

    if (ci_name !== undefined || ci_description !== undefined) {
      const oldCiData = await client.query(
        "SELECT ci_name, description FROM ci WHERE ci_id = $1",
        [ci_id]
      );

      if (oldCiData.rows.length > 0) {
        // Check if the row exists
        oldCiValues.ci_name = oldCiData.rows[0].ci_name;
        oldCiValues.description = oldCiData.rows[0].description;
      } else {
        return res.status(404).json({ error: "CI not found" });
      }
    }

    if (
      user_id !== undefined ||
      ci_service_id !== undefined ||
      ci_classification_id !== undefined ||
      ci_category_id !== undefined
    ) {
      const oldUserCiData = await client.query(
        "SELECT user_id, ci_service_id, ci_classification_id, ci_category_id FROM user_ci_relation WHERE ci_id = $1",
        [ci_id]
      );

      if (oldUserCiData.rows.length > 0) {
        // Check if the row exists
        oldUserCiValues.user_id = oldUserCiData.rows[0].user_id;
        oldUserCiValues.ci_service_id = oldUserCiData.rows[0].ci_service_id;
        oldUserCiValues.ci_classification_id =
          oldUserCiData.rows[0].ci_classification_id;
        oldUserCiValues.ci_category_id = oldUserCiData.rows[0].ci_category_id;
      } else {
        return res.status(404).json({ error: "User CI relation not found" });
      }
    }

    // Step 2: Prepare for updates to the `ci` table
    const ciFields = [];
    const ciValues = [];
    if (ci_name !== undefined) {
      ciFields.push(`ci_name = $${ciFields.length + 1}`);
      ciValues.push(ci_name);
    }
    if (ci_description !== undefined) {
      ciFields.push(`description = $${ciFields.length + 1}`);
      ciValues.push(ci_description);
    }

    // Step 3: Update the `ci` table
    if (ciFields.length > 0) {
      let updateCiQuery = "UPDATE ci SET updated_at = NOW(), ";
      updateCiQuery += ciFields.join(", ");
      updateCiQuery += ` WHERE ci_id = $${ciFields.length + 1} RETURNING *;`;
      ciValues.push(ci_id);

      const ciResult = await client.query(updateCiQuery, ciValues);
      if (ciResult.rowCount === 0) {
        await client.query("ROLLBACK");
        return res.status(404).json({ error: "CI not found" });
      }
    }

    // Step 4: Prepare for updates to the `user_ci_relation` table
    const relationFields = [];
    const relationValues = [];
    if (user_id !== undefined) {
      relationFields.push(`user_id = $${relationFields.length + 1}`);
      relationValues.push(user_id);
    }
    if (ci_service_id !== undefined) {
      relationFields.push(`ci_service_id = $${relationFields.length + 1}`);
      relationValues.push(ci_service_id);
    }
    if (ci_classification_id !== undefined) {
      relationFields.push(
        `ci_classification_id = $${relationFields.length + 1}`
      );
      relationValues.push(ci_classification_id);
    }
    if (ci_category_id !== undefined) {
      relationFields.push(`ci_category_id = $${relationFields.length + 1}`);
      relationValues.push(ci_category_id);
    }

    // Step 5: Update the `user_ci_relation` table
    if (relationFields.length > 0) {
      let updateRelationQuery = "UPDATE user_ci_relation SET ";
      updateRelationQuery += relationFields.join(", ");
      updateRelationQuery += ` WHERE ci_id = $${relationFields.length + 1};`;
      relationValues.push(ci_id);

      const relationResult = await client.query(
        updateRelationQuery,
        relationValues
      );
      if (relationResult.rowCount === 0) {
        await client.query("ROLLBACK");
        return res.status(404).json({ error: "User CI relation not found" });
      }
    }

    // Step 6: Update the `ci_assigned_to` table
    if (user_id !== undefined) {
      const updateAssignedQuery = `
        UPDATE ci_assigned_to SET user_id = $1 WHERE ci_id = $2;
      `;
      await client.query(updateAssignedQuery, [user_id, ci_id]);
    }

    // Step 7: Log changes in ci_audit table
    const oldValues = JSON.stringify({
      ci: oldCiValues,
      user_ci_relation: oldUserCiValues,
    });
    const newValues = JSON.stringify({
      ci_name,
      description: ci_description,
      user_id,
      ci_service_id,
      ci_classification_id,
      ci_category_id,
    });

    const auditQuery = `
      INSERT INTO ci_audit (
        ci_id, user_id, old_values, new_values, updated_at
      ) VALUES ($1, $2, $3, $4, NOW())
    `;
    await client.query(auditQuery, [ci_id, user, oldValues, newValues]);

    await client.query("COMMIT"); // Commit transaction

    res.status(200).json({ message: "CI updated successfully" });
  } catch (err) {
    await client.query("ROLLBACK"); // Rollback transaction in case of error
    console.error(err.message);
    res.status(500).json({ error: "Server error" });
  } finally {
    client.release(); // Release the client back to the pool
  }
};

const getCiDetailsByUserId = async (req, res) => {
  try {
    const userId = req.params.userId; // Get user_id from request parameters

    // SQL query to fetch ci_id and ci_name
    const query = `
      SELECT 
        ci.ci_id,
        ci.ci_name
      FROM 
        public.user_ci_relation ucr
      JOIN 
        public.ci 
      ON 
        ucr.ci_id = ci.ci_id
      WHERE 
        ucr.user_id = $1
    `;

    // Execute query
    const result = await pool.query(query, [userId]);

    // Check if any records are found
    if (result.rows.length > 0) {
      // Convert ci_id to number before returning
      const response = result.rows.map((row) => ({
        ci_id: Number(row.ci_id), // Convert to number
        ci_name: row.ci_name,
      }));
      res.status(200).json({
        status: 200, // Include status code
        message: "Request successful", // Include a message
        data: response, // Attach the original response object
      });
      // Return the data as JSON
    } else {
      res.status(200).json({
        status: 204, // Include the status code in the response
        message: "No CI records found for the given User",
      });
    }
  } catch (error) {
    console.error("Error fetching CI details:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

module.exports = {
  addCi,
  getCiData,
  getCiDataById,
  updateCi,
  getCiDetailsByUserId,
  ciBulkUpload,
};
